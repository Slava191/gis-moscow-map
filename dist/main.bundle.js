/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/ngraph.events/index.js":
/*!*********************************************!*\
  !*** ./node_modules/ngraph.events/index.js ***!
  \*********************************************/
/***/ ((module) => {

eval("module.exports = function(subject) {\n  validateSubject(subject);\n\n  var eventsStorage = createEventsStorage(subject);\n  subject.on = eventsStorage.on;\n  subject.off = eventsStorage.off;\n  subject.fire = eventsStorage.fire;\n  return subject;\n};\n\nfunction createEventsStorage(subject) {\n  // Store all event listeners to this hash. Key is event name, value is array\n  // of callback records.\n  //\n  // A callback record consists of callback function and its optional context:\n  // { 'eventName' => [{callback: function, ctx: object}] }\n  var registeredEvents = Object.create(null);\n\n  return {\n    on: function (eventName, callback, ctx) {\n      if (typeof callback !== 'function') {\n        throw new Error('callback is expected to be a function');\n      }\n      var handlers = registeredEvents[eventName];\n      if (!handlers) {\n        handlers = registeredEvents[eventName] = [];\n      }\n      handlers.push({callback: callback, ctx: ctx});\n\n      return subject;\n    },\n\n    off: function (eventName, callback) {\n      var wantToRemoveAll = (typeof eventName === 'undefined');\n      if (wantToRemoveAll) {\n        // Killing old events storage should be enough in this case:\n        registeredEvents = Object.create(null);\n        return subject;\n      }\n\n      if (registeredEvents[eventName]) {\n        var deleteAllCallbacksForEvent = (typeof callback !== 'function');\n        if (deleteAllCallbacksForEvent) {\n          delete registeredEvents[eventName];\n        } else {\n          var callbacks = registeredEvents[eventName];\n          for (var i = 0; i < callbacks.length; ++i) {\n            if (callbacks[i].callback === callback) {\n              callbacks.splice(i, 1);\n            }\n          }\n        }\n      }\n\n      return subject;\n    },\n\n    fire: function (eventName) {\n      var callbacks = registeredEvents[eventName];\n      if (!callbacks) {\n        return subject;\n      }\n\n      var fireArguments;\n      if (arguments.length > 1) {\n        fireArguments = Array.prototype.splice.call(arguments, 1);\n      }\n      for(var i = 0; i < callbacks.length; ++i) {\n        var callbackInfo = callbacks[i];\n        callbackInfo.callback.apply(callbackInfo.ctx, fireArguments);\n      }\n\n      return subject;\n    }\n  };\n}\n\nfunction validateSubject(subject) {\n  if (!subject) {\n    throw new Error('Eventify cannot use falsy object as events subject');\n  }\n  var reservedWords = ['on', 'fire', 'off'];\n  for (var i = 0; i < reservedWords.length; ++i) {\n    if (subject.hasOwnProperty(reservedWords[i])) {\n      throw new Error(\"Subject cannot be eventified, since it already has property '\" + reservedWords[i] + \"'\");\n    }\n  }\n}\n\n\n//# sourceURL=webpack://gis-moscow-map/./node_modules/ngraph.events/index.js?");

/***/ }),

/***/ "./node_modules/ngraph.graph/index.js":
/*!********************************************!*\
  !*** ./node_modules/ngraph.graph/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @fileOverview Contains definition of the core graph object.\n */\n\n// TODO: need to change storage layer:\n// 1. Be able to get all nodes O(1)\n// 2. Be able to get number of links O(1)\n\n/**\n * @example\n *  var graph = require('ngraph.graph')();\n *  graph.addNode(1);     // graph has one node.\n *  graph.addLink(2, 3);  // now graph contains three nodes and one link.\n *\n */\nmodule.exports = createGraph;\n\nvar eventify = __webpack_require__(/*! ngraph.events */ \"./node_modules/ngraph.events/index.js\");\n\n/**\n * Creates a new graph\n */\nfunction createGraph(options) {\n  // Graph structure is maintained as dictionary of nodes\n  // and array of links. Each node has 'links' property which\n  // hold all links related to that node. And general links\n  // array is used to speed up all links enumeration. This is inefficient\n  // in terms of memory, but simplifies coding.\n  options = options || {};\n  if ('uniqueLinkId' in options) {\n    console.warn(\n      'ngraph.graph: Starting from version 0.14 `uniqueLinkId` is deprecated.\\n' +\n      'Use `multigraph` option instead\\n',\n      '\\n',\n      'Note: there is also change in default behavior: From now on each graph\\n'+\n      'is considered to be not a multigraph by default (each edge is unique).'\n    );\n\n    options.multigraph = options.uniqueLinkId;\n  }\n\n  // Dear reader, the non-multigraphs do not guarantee that there is only\n  // one link for a given pair of node. When this option is set to false\n  // we can save some memory and CPU (18% faster for non-multigraph);\n  if (options.multigraph === undefined) options.multigraph = false;\n\n  var nodes = typeof Object.create === 'function' ? Object.create(null) : {},\n    links = [],\n    // Hash of multi-edges. Used to track ids of edges between same nodes\n    multiEdges = {},\n    nodesCount = 0,\n    suspendEvents = 0,\n\n    forEachNode = createNodeIterator(),\n    createLink = options.multigraph ? createUniqueLink : createSingleLink,\n\n    // Our graph API provides means to listen to graph changes. Users can subscribe\n    // to be notified about changes in the graph by using `on` method. However\n    // in some cases they don't use it. To avoid unnecessary memory consumption\n    // we will not record graph changes until we have at least one subscriber.\n    // Code below supports this optimization.\n    //\n    // Accumulates all changes made during graph updates.\n    // Each change element contains:\n    //  changeType - one of the strings: 'add', 'remove' or 'update';\n    //  node - if change is related to node this property is set to changed graph's node;\n    //  link - if change is related to link this property is set to changed graph's link;\n    changes = [],\n    recordLinkChange = noop,\n    recordNodeChange = noop,\n    enterModification = noop,\n    exitModification = noop;\n\n  // this is our public API:\n  var graphPart = {\n    /**\n     * Adds node to the graph. If node with given id already exists in the graph\n     * its data is extended with whatever comes in 'data' argument.\n     *\n     * @param nodeId the node's identifier. A string or number is preferred.\n     * @param [data] additional data for the node being added. If node already\n     *   exists its data object is augmented with the new one.\n     *\n     * @return {node} The newly added node or node with given id if it already exists.\n     */\n    addNode: addNode,\n\n    /**\n     * Adds a link to the graph. The function always create a new\n     * link between two nodes. If one of the nodes does not exists\n     * a new node is created.\n     *\n     * @param fromId link start node id;\n     * @param toId link end node id;\n     * @param [data] additional data to be set on the new link;\n     *\n     * @return {link} The newly created link\n     */\n    addLink: addLink,\n\n    /**\n     * Removes link from the graph. If link does not exist does nothing.\n     *\n     * @param link - object returned by addLink() or getLinks() methods.\n     *\n     * @returns true if link was removed; false otherwise.\n     */\n    removeLink: removeLink,\n\n    /**\n     * Removes node with given id from the graph. If node does not exist in the graph\n     * does nothing.\n     *\n     * @param nodeId node's identifier passed to addNode() function.\n     *\n     * @returns true if node was removed; false otherwise.\n     */\n    removeNode: removeNode,\n\n    /**\n     * Gets node with given identifier. If node does not exist undefined value is returned.\n     *\n     * @param nodeId requested node identifier;\n     *\n     * @return {node} in with requested identifier or undefined if no such node exists.\n     */\n    getNode: getNode,\n\n    /**\n     * Gets number of nodes in this graph.\n     *\n     * @return number of nodes in the graph.\n     */\n    getNodesCount: function () {\n      return nodesCount;\n    },\n\n    /**\n     * Gets total number of links in the graph.\n     */\n    getLinksCount: function () {\n      return links.length;\n    },\n\n    /**\n     * Gets all links (inbound and outbound) from the node with given id.\n     * If node with given id is not found null is returned.\n     *\n     * @param nodeId requested node identifier.\n     *\n     * @return Array of links from and to requested node if such node exists;\n     *   otherwise null is returned.\n     */\n    getLinks: getLinks,\n\n    /**\n     * Invokes callback on each node of the graph.\n     *\n     * @param {Function(node)} callback Function to be invoked. The function\n     *   is passed one argument: visited node.\n     */\n    forEachNode: forEachNode,\n\n    /**\n     * Invokes callback on every linked (adjacent) node to the given one.\n     *\n     * @param nodeId Identifier of the requested node.\n     * @param {Function(node, link)} callback Function to be called on all linked nodes.\n     *   The function is passed two parameters: adjacent node and link object itself.\n     * @param oriented if true graph treated as oriented.\n     */\n    forEachLinkedNode: forEachLinkedNode,\n\n    /**\n     * Enumerates all links in the graph\n     *\n     * @param {Function(link)} callback Function to be called on all links in the graph.\n     *   The function is passed one parameter: graph's link object.\n     *\n     * Link object contains at least the following fields:\n     *  fromId - node id where link starts;\n     *  toId - node id where link ends,\n     *  data - additional data passed to graph.addLink() method.\n     */\n    forEachLink: forEachLink,\n\n    /**\n     * Suspend all notifications about graph changes until\n     * endUpdate is called.\n     */\n    beginUpdate: enterModification,\n\n    /**\n     * Resumes all notifications about graph changes and fires\n     * graph 'changed' event in case there are any pending changes.\n     */\n    endUpdate: exitModification,\n\n    /**\n     * Removes all nodes and links from the graph.\n     */\n    clear: clear,\n\n    /**\n     * Detects whether there is a link between two nodes.\n     * Operation complexity is O(n) where n - number of links of a node.\n     * NOTE: this function is synonim for getLink()\n     *\n     * @returns link if there is one. null otherwise.\n     */\n    hasLink: getLink,\n\n    /**\n     * Detects whether there is a node with given id\n     * \n     * Operation complexity is O(1)\n     * NOTE: this function is synonim for getNode()\n     *\n     * @returns node if there is one; Falsy value otherwise.\n     */\n    hasNode: getNode,\n\n    /**\n     * Gets an edge between two nodes.\n     * Operation complexity is O(n) where n - number of links of a node.\n     *\n     * @param {string} fromId link start identifier\n     * @param {string} toId link end identifier\n     *\n     * @returns link if there is one. null otherwise.\n     */\n    getLink: getLink\n  };\n\n  // this will add `on()` and `fire()` methods.\n  eventify(graphPart);\n\n  monitorSubscribers();\n\n  return graphPart;\n\n  function monitorSubscribers() {\n    var realOn = graphPart.on;\n\n    // replace real `on` with our temporary on, which will trigger change\n    // modification monitoring:\n    graphPart.on = on;\n\n    function on() {\n      // now it's time to start tracking stuff:\n      graphPart.beginUpdate = enterModification = enterModificationReal;\n      graphPart.endUpdate = exitModification = exitModificationReal;\n      recordLinkChange = recordLinkChangeReal;\n      recordNodeChange = recordNodeChangeReal;\n\n      // this will replace current `on` method with real pub/sub from `eventify`.\n      graphPart.on = realOn;\n      // delegate to real `on` handler:\n      return realOn.apply(graphPart, arguments);\n    }\n  }\n\n  function recordLinkChangeReal(link, changeType) {\n    changes.push({\n      link: link,\n      changeType: changeType\n    });\n  }\n\n  function recordNodeChangeReal(node, changeType) {\n    changes.push({\n      node: node,\n      changeType: changeType\n    });\n  }\n\n  function addNode(nodeId, data) {\n    if (nodeId === undefined) {\n      throw new Error('Invalid node identifier');\n    }\n\n    enterModification();\n\n    var node = getNode(nodeId);\n    if (!node) {\n      node = new Node(nodeId, data);\n      nodesCount++;\n      recordNodeChange(node, 'add');\n    } else {\n      node.data = data;\n      recordNodeChange(node, 'update');\n    }\n\n    nodes[nodeId] = node;\n\n    exitModification();\n    return node;\n  }\n\n  function getNode(nodeId) {\n    return nodes[nodeId];\n  }\n\n  function removeNode(nodeId) {\n    var node = getNode(nodeId);\n    if (!node) {\n      return false;\n    }\n\n    enterModification();\n\n    var prevLinks = node.links;\n    if (prevLinks) {\n      node.links = null;\n      for(var i = 0; i < prevLinks.length; ++i) {\n        removeLink(prevLinks[i]);\n      }\n    }\n\n    delete nodes[nodeId];\n    nodesCount--;\n\n    recordNodeChange(node, 'remove');\n\n    exitModification();\n\n    return true;\n  }\n\n\n  function addLink(fromId, toId, data) {\n    enterModification();\n\n    var fromNode = getNode(fromId) || addNode(fromId);\n    var toNode = getNode(toId) || addNode(toId);\n\n    var link = createLink(fromId, toId, data);\n\n    links.push(link);\n\n    // TODO: this is not cool. On large graphs potentially would consume more memory.\n    addLinkToNode(fromNode, link);\n    if (fromId !== toId) {\n      // make sure we are not duplicating links for self-loops\n      addLinkToNode(toNode, link);\n    }\n\n    recordLinkChange(link, 'add');\n\n    exitModification();\n\n    return link;\n  }\n\n  function createSingleLink(fromId, toId, data) {\n    var linkId = makeLinkId(fromId, toId);\n    return new Link(fromId, toId, data, linkId);\n  }\n\n  function createUniqueLink(fromId, toId, data) {\n    // TODO: Get rid of this method.\n    var linkId = makeLinkId(fromId, toId);\n    var isMultiEdge = multiEdges.hasOwnProperty(linkId);\n    if (isMultiEdge || getLink(fromId, toId)) {\n      if (!isMultiEdge) {\n        multiEdges[linkId] = 0;\n      }\n      var suffix = '@' + (++multiEdges[linkId]);\n      linkId = makeLinkId(fromId + suffix, toId + suffix);\n    }\n\n    return new Link(fromId, toId, data, linkId);\n  }\n\n  function getLinks(nodeId) {\n    var node = getNode(nodeId);\n    return node ? node.links : null;\n  }\n\n  function removeLink(link) {\n    if (!link) {\n      return false;\n    }\n    var idx = indexOfElementInArray(link, links);\n    if (idx < 0) {\n      return false;\n    }\n\n    enterModification();\n\n    links.splice(idx, 1);\n\n    var fromNode = getNode(link.fromId);\n    var toNode = getNode(link.toId);\n\n    if (fromNode) {\n      idx = indexOfElementInArray(link, fromNode.links);\n      if (idx >= 0) {\n        fromNode.links.splice(idx, 1);\n      }\n    }\n\n    if (toNode) {\n      idx = indexOfElementInArray(link, toNode.links);\n      if (idx >= 0) {\n        toNode.links.splice(idx, 1);\n      }\n    }\n\n    recordLinkChange(link, 'remove');\n\n    exitModification();\n\n    return true;\n  }\n\n  function getLink(fromNodeId, toNodeId) {\n    // TODO: Use sorted links to speed this up\n    var node = getNode(fromNodeId),\n      i;\n    if (!node || !node.links) {\n      return null;\n    }\n\n    for (i = 0; i < node.links.length; ++i) {\n      var link = node.links[i];\n      if (link.fromId === fromNodeId && link.toId === toNodeId) {\n        return link;\n      }\n    }\n\n    return null; // no link.\n  }\n\n  function clear() {\n    enterModification();\n    forEachNode(function(node) {\n      removeNode(node.id);\n    });\n    exitModification();\n  }\n\n  function forEachLink(callback) {\n    var i, length;\n    if (typeof callback === 'function') {\n      for (i = 0, length = links.length; i < length; ++i) {\n        callback(links[i]);\n      }\n    }\n  }\n\n  function forEachLinkedNode(nodeId, callback, oriented) {\n    var node = getNode(nodeId);\n\n    if (node && node.links && typeof callback === 'function') {\n      if (oriented) {\n        return forEachOrientedLink(node.links, nodeId, callback);\n      } else {\n        return forEachNonOrientedLink(node.links, nodeId, callback);\n      }\n    }\n  }\n\n  function forEachNonOrientedLink(links, nodeId, callback) {\n    var quitFast;\n    for (var i = 0; i < links.length; ++i) {\n      var link = links[i];\n      var linkedNodeId = link.fromId === nodeId ? link.toId : link.fromId;\n\n      quitFast = callback(nodes[linkedNodeId], link);\n      if (quitFast) {\n        return true; // Client does not need more iterations. Break now.\n      }\n    }\n  }\n\n  function forEachOrientedLink(links, nodeId, callback) {\n    var quitFast;\n    for (var i = 0; i < links.length; ++i) {\n      var link = links[i];\n      if (link.fromId === nodeId) {\n        quitFast = callback(nodes[link.toId], link);\n        if (quitFast) {\n          return true; // Client does not need more iterations. Break now.\n        }\n      }\n    }\n  }\n\n  // we will not fire anything until users of this library explicitly call `on()`\n  // method.\n  function noop() {}\n\n  // Enter, Exit modification allows bulk graph updates without firing events.\n  function enterModificationReal() {\n    suspendEvents += 1;\n  }\n\n  function exitModificationReal() {\n    suspendEvents -= 1;\n    if (suspendEvents === 0 && changes.length > 0) {\n      graphPart.fire('changed', changes);\n      changes.length = 0;\n    }\n  }\n\n  function createNodeIterator() {\n    // Object.keys iterator is 1.3x faster than `for in` loop.\n    // See `https://github.com/anvaka/ngraph.graph/tree/bench-for-in-vs-obj-keys`\n    // branch for perf test\n    return Object.keys ? objectKeysIterator : forInIterator;\n  }\n\n  function objectKeysIterator(callback) {\n    if (typeof callback !== 'function') {\n      return;\n    }\n\n    var keys = Object.keys(nodes);\n    for (var i = 0; i < keys.length; ++i) {\n      if (callback(nodes[keys[i]])) {\n        return true; // client doesn't want to proceed. Return.\n      }\n    }\n  }\n\n  function forInIterator(callback) {\n    if (typeof callback !== 'function') {\n      return;\n    }\n    var node;\n\n    for (node in nodes) {\n      if (callback(nodes[node])) {\n        return true; // client doesn't want to proceed. Return.\n      }\n    }\n  }\n}\n\n// need this for old browsers. Should this be a separate module?\nfunction indexOfElementInArray(element, array) {\n  if (!array) return -1;\n\n  if (array.indexOf) {\n    return array.indexOf(element);\n  }\n\n  var len = array.length,\n    i;\n\n  for (i = 0; i < len; i += 1) {\n    if (array[i] === element) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\n/**\n * Internal structure to represent node;\n */\nfunction Node(id, data) {\n  this.id = id;\n  this.links = null;\n  this.data = data;\n}\n\nfunction addLinkToNode(node, link) {\n  if (node.links) {\n    node.links.push(link);\n  } else {\n    node.links = [link];\n  }\n}\n\n/**\n * Internal structure to represent links;\n */\nfunction Link(fromId, toId, data, id) {\n  this.fromId = fromId;\n  this.toId = toId;\n  this.data = data;\n  this.id = id;\n}\n\nfunction hashCode(str) {\n  var hash = 0, i, chr, len;\n  if (str.length == 0) return hash;\n  for (i = 0, len = str.length; i < len; i++) {\n    chr   = str.charCodeAt(i);\n    hash  = ((hash << 5) - hash) + chr;\n    hash |= 0; // Convert to 32bit integer\n  }\n  return hash;\n}\n\nfunction makeLinkId(fromId, toId) {\n  return fromId.toString() + '👉 ' + toId.toString();\n}\n\n\n//# sourceURL=webpack://gis-moscow-map/./node_modules/ngraph.graph/index.js?");

/***/ }),

/***/ "./src/a-star/NodeHeap.js":
/*!********************************!*\
  !*** ./src/a-star/NodeHeap.js ***!
  \********************************/
/***/ ((module) => {

eval("/**\n * Based on https://github.com/mourner/tinyqueue\n * Copyright (c) 2017, Vladimir Agafonkin https://github.com/mourner/tinyqueue/blob/master/LICENSE\n * \n * Adapted for PathFinding needs by @anvaka\n * Copyright (c) 2017, Andrei Kashcha\n */\nmodule.exports = NodeHeap;\n\nfunction NodeHeap(data, options) {\n  if (!(this instanceof NodeHeap)) return new NodeHeap(data, options);\n\n  if (!Array.isArray(data)) {\n    // assume first argument is our config object;\n    options = data;\n    data = [];\n  }\n\n  options = options || {};\n\n  this.data = data || [];\n  this.length = this.data.length;\n  this.compare = options.compare || defaultCompare;\n  this.setNodeId = options.setNodeId || noop;\n\n  if (this.length > 0) {\n    for (var i = (this.length >> 1); i >= 0; i--) this._down(i);\n  }\n\n  if (options.setNodeId) {\n    for (var i = 0; i < this.length; ++i) {\n      this.setNodeId(this.data[i], i);\n    }\n  }\n}\n\nfunction noop() {}\n\nfunction defaultCompare(a, b) {\n  return a - b;\n}\n\nNodeHeap.prototype = {\n\n  push: function (item) {\n    this.data.push(item);\n    this.setNodeId(item, this.length);\n    this.length++;\n    this._up(this.length - 1);\n  },\n\n  pop: function () {\n    if (this.length === 0) return undefined;\n\n    var top = this.data[0];\n    this.length--;\n\n    if (this.length > 0) {\n      this.data[0] = this.data[this.length];\n      this.setNodeId(this.data[0], 0);\n      this._down(0);\n    }\n    this.data.pop();\n\n    return top;\n  },\n\n  peek: function () {\n    return this.data[0];\n  },\n\n  updateItem: function (pos) {\n    this._down(pos);\n    this._up(pos);\n  },\n\n  _up: function (pos) {\n    var data = this.data;\n    var compare = this.compare;\n    var setNodeId = this.setNodeId;\n    var item = data[pos];\n\n    while (pos > 0) {\n      var parent = (pos - 1) >> 1;\n      var current = data[parent];\n      if (compare(item, current) >= 0) break;\n        data[pos] = current;\n\n       setNodeId(current, pos);\n       pos = parent;\n    }\n\n    data[pos] = item;\n    setNodeId(item, pos);\n  },\n\n  _down: function (pos) {\n    var data = this.data;\n    var compare = this.compare;\n    var halfLength = this.length >> 1;\n    var item = data[pos];\n    var setNodeId = this.setNodeId;\n\n    while (pos < halfLength) {\n      var left = (pos << 1) + 1;\n      var right = left + 1;\n      var best = data[left];\n\n      if (right < this.length && compare(data[right], best) < 0) {\n        left = right;\n        best = data[right];\n      }\n      if (compare(best, item) >= 0) break;\n\n      data[pos] = best;\n      setNodeId(best, pos);\n      pos = left;\n    }\n\n    data[pos] = item;\n    setNodeId(item, pos);\n  }\n};\n\n//# sourceURL=webpack://gis-moscow-map/./src/a-star/NodeHeap.js?");

/***/ }),

/***/ "./src/a-star/a-star.js":
/*!******************************!*\
  !*** ./src/a-star/a-star.js ***!
  \******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Performs a uni-directional A Star search on graph.\n * \n * We will try to minimize f(n) = g(n) + h(n), where\n * g(n) is actual distance from source node to `n`, and\n * h(n) is heuristic distance from `n` to target node.\n */\nmodule.exports = aStarPathSearch;\n\nvar NodeHeap = __webpack_require__(/*! ./NodeHeap */ \"./src/a-star/NodeHeap.js\");\nvar makeSearchStatePool = __webpack_require__(/*! ./makeSearchStatePool */ \"./src/a-star/makeSearchStatePool.js\");\nvar heuristics = __webpack_require__(/*! ./heuristics */ \"./src/a-star/heuristics.js\");\nvar defaultSettings = __webpack_require__(/*! ./defaultSettings.js */ \"./src/a-star/defaultSettings.js\");\n\nvar NO_PATH = defaultSettings.NO_PATH;\n\nmodule.exports.l2 = heuristics.l2;\nmodule.exports.l1 = heuristics.l1;\n\n/**\n * Creates a new instance of pathfinder. A pathfinder has just one method:\n * `find(fromId, toId)`, it may be extended in future.\n * \n * @param {ngraph.graph} graph instance. See https://github.com/anvaka/ngraph.graph\n * @param {Object} options that configures search\n * @param {Function(a, b)} options.heuristic - a function that returns estimated distance between\n * nodes `a` and `b`. This function should never overestimate actual distance between two\n * nodes (otherwise the found path will not be the shortest). Defaults function returns 0,\n * which makes this search equivalent to Dijkstra search.\n * @param {Function(a, b)} options.distance - a function that returns actual distance between two\n * nodes `a` and `b`. By default this is set to return graph-theoretical distance (always 1);\n * @param {Boolean} options.oriented - whether graph should be considered oriented or not.\n * \n * @returns {Object} A pathfinder with single method `find()`.\n */\nfunction aStarPathSearch(graph, options) {\n  options = options || {};\n  // whether traversal should be considered over oriented graph.\n  var oriented = options.oriented;\n\n  var heuristic = options.heuristic;\n  if (!heuristic) heuristic = defaultSettings.heuristic;\n\n  var distance = options.distance;\n  if (!distance) distance = defaultSettings.distance;\n  var pool = makeSearchStatePool();\n\n  return {\n    /**\n     * Finds a path between node `fromId` and `toId`.\n     * @returns {Array} of nodes between `toId` and `fromId`. Empty array is returned\n     * if no path is found.\n     */\n    find: find\n  };\n\n  function find(fromId, toId) {\n    var from = graph.getNode(fromId);\n    if (!from) throw new Error('fromId is not defined in this graph: ' + fromId);\n    var to = graph.getNode(toId);\n    if (!to) throw new Error('toId is not defined in this graph: ' + toId);\n    pool.reset();\n\n    // Maps nodeId to NodeSearchState.\n    var nodeState = new Map();\n\n    // the nodes that we still need to evaluate\n    var openSet = new NodeHeap({\n      compare: defaultSettings.compareFScore,\n      setNodeId: defaultSettings.setHeapIndex\n    });\n\n    var startNode = pool.createNewState(from);\n    nodeState.set(fromId, startNode);\n\n    // For the first node, fScore is completely heuristic.\n    startNode.fScore = heuristic(from, to);\n\n    // The cost of going from start to start is zero.\n    startNode.distanceToSource = 0;\n    openSet.push(startNode);\n    startNode.open = 1;\n\n    var cameFrom;\n\n    while (openSet.length > 0) {\n      cameFrom = openSet.pop();\n      if (goalReached(cameFrom, to)) return reconstructPath(cameFrom);\n\n      // no need to visit this node anymore\n      cameFrom.closed = true;\n      graph.forEachLinkedNode(cameFrom.node.id, visitNeighbour, oriented);\n    }\n\n    // If we got here, then there is no path.\n    return NO_PATH;\n\n    function visitNeighbour(otherNode, link) {\n      var otherSearchState = nodeState.get(otherNode.id);\n      if (!otherSearchState) {\n        otherSearchState = pool.createNewState(otherNode);\n        nodeState.set(otherNode.id, otherSearchState);\n      }\n\n      if (otherSearchState.closed) {\n        // Already processed this node.\n        return;\n      }\n      if (otherSearchState.open === 0) {\n        // Remember this node.\n        openSet.push(otherSearchState);\n        otherSearchState.open = 1;\n      }\n\n      var tentativeDistance = cameFrom.distanceToSource + distance(otherNode, cameFrom.node, link);\n      if (tentativeDistance >= otherSearchState.distanceToSource) {\n        // This would only make our path longer. Ignore this route.\n        return;\n      }\n\n      // bingo! we found shorter path:\n      otherSearchState.parent = cameFrom;\n      otherSearchState.distanceToSource = tentativeDistance;\n      otherSearchState.fScore = tentativeDistance + heuristic(otherSearchState.node, to);\n\n      openSet.updateItem(otherSearchState.heapIndex);\n    }\n  }\n}\n\nfunction goalReached(searchState, targetNode) {\n  return searchState.node === targetNode;\n}\n\nfunction reconstructPath(searchState) {\n  var path = [searchState.node];\n  var parent = searchState.parent;\n\n  while (parent) {\n    path.push(parent.node);\n    parent = parent.parent;\n  }\n\n  return path;\n}\n\n\n//# sourceURL=webpack://gis-moscow-map/./src/a-star/a-star.js?");

/***/ }),

/***/ "./src/a-star/defaultSettings.js":
/*!***************************************!*\
  !*** ./src/a-star/defaultSettings.js ***!
  \***************************************/
/***/ ((module) => {

eval("// We reuse instance of array, but we trie to freeze it as well,\n// so that consumers don't modify it. Maybe it's a bad idea.\nvar NO_PATH = [];\nif (typeof Object.freeze === 'function') Object.freeze(NO_PATH);\n\nmodule.exports = {\n  // Path search settings\n  heuristic: blindHeuristic,\n  distance: constantDistance,\n  compareFScore: compareFScore,\n  NO_PATH: NO_PATH,\n\n  // heap settings\n  setHeapIndex: setHeapIndex,\n\n  // nba:\n  setH1: setH1,\n  setH2: setH2,\n  compareF1Score: compareF1Score,\n  compareF2Score: compareF2Score,\n}\n\nfunction blindHeuristic(/* a, b */) {\n  // blind heuristic makes this search equal to plain Dijkstra path search.\n  return 0;\n}\n\nfunction constantDistance(/* a, b */) {\n  return 1;\n}\n\nfunction compareFScore(a, b) {\n  var result = a.fScore - b.fScore;\n  // TODO: Can I improve speed with smarter ties-breaking?\n  // I tried distanceToSource, but it didn't seem to have much effect\n  return result;\n}\n\nfunction setHeapIndex(nodeSearchState, heapIndex) {\n  nodeSearchState.heapIndex = heapIndex;\n}\n\nfunction compareF1Score(a, b) {\n  return a.f1 - b.f1;\n}\n\nfunction compareF2Score(a, b) {\n  return a.f2 - b.f2;\n}\n\nfunction setH1(node, heapIndex) {\n  node.h1 = heapIndex;\n}\n\nfunction setH2(node, heapIndex) {\n  node.h2 = heapIndex;\n}\n\n//# sourceURL=webpack://gis-moscow-map/./src/a-star/defaultSettings.js?");

/***/ }),

/***/ "./src/a-star/heuristics.js":
/*!**********************************!*\
  !*** ./src/a-star/heuristics.js ***!
  \**********************************/
/***/ ((module) => {

eval("module.exports = {\n  l2: l2,\n  l1: l1\n};\n\n/**\n * Euclid distance (l2 norm);\n * \n * @param {*} a \n * @param {*} b \n */\nfunction l2(a, b) {\n  var dx = a.x - b.x;\n  var dy = a.y - b.y;\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\n/**\n * Manhattan distance (l1 norm);\n * @param {*} a \n * @param {*} b \n */\nfunction l1(a, b) {\n  var dx = a.x - b.x;\n  var dy = a.y - b.y;\n  return Math.abs(dx) + Math.abs(dy);\n}\n\n\n//# sourceURL=webpack://gis-moscow-map/./src/a-star/heuristics.js?");

/***/ }),

/***/ "./src/a-star/makeSearchStatePool.js":
/*!*******************************************!*\
  !*** ./src/a-star/makeSearchStatePool.js ***!
  \*******************************************/
/***/ ((module) => {

eval("/**\n * This class represents a single search node in the exploration tree for\n * A* algorithm.\n * \n * @param {Object} node  original node in the graph\n */\nfunction NodeSearchState(node) {\n  this.node = node;\n\n  // How we came to this node?\n  this.parent = null;\n\n  this.closed = false;\n  this.open = 0;\n\n  this.distanceToSource = Number.POSITIVE_INFINITY;\n  // the f(n) = g(n) + h(n) value\n  this.fScore = Number.POSITIVE_INFINITY;\n\n  // used to reconstruct heap when fScore is updated.\n  this.heapIndex = -1;\n};\n\nfunction makeSearchStatePool() {\n  var currentInCache = 0;\n  var nodeCache = [];\n\n  return {\n    createNewState: createNewState,\n    reset: reset\n  };\n\n  function reset() {\n    currentInCache = 0;\n  }\n\n  function createNewState(node) {\n    var cached = nodeCache[currentInCache];\n    if (cached) {\n      // TODO: This almost duplicates constructor code. Not sure if\n      // it would impact performance if I move this code into a function\n      cached.node = node;\n      // How we came to this node?\n      cached.parent = null;\n\n      cached.closed = false;\n      cached.open = 0;\n\n      cached.distanceToSource = Number.POSITIVE_INFINITY;\n      // the f(n) = g(n) + h(n) value\n      cached.fScore = Number.POSITIVE_INFINITY;\n\n      // used to reconstruct heap when fScore is updated.\n      cached.heapIndex = -1;\n\n    } else {\n      cached = new NodeSearchState(node);\n      nodeCache[currentInCache] = cached;\n    }\n    currentInCache++;\n    return cached;\n  }\n}\nmodule.exports = makeSearchStatePool;\n\n//# sourceURL=webpack://gis-moscow-map/./src/a-star/makeSearchStatePool.js?");

/***/ }),

/***/ "./src/draw.js":
/*!*********************!*\
  !*** ./src/draw.js ***!
  \*********************/
/***/ ((module) => {

eval("module.exports = class {\r\n\r\n    constructor(ctx, options = {}){\r\n\r\n        this.ctx = ctx\r\n    \r\n        this.scale = options.scale || 0.05\r\n        this.topOffset = options.topOffset || 40500\r\n        this.leftOffset = options.leftOffset || 0\r\n        this.gitHubPages = options.gitHubPages || false\r\n\r\n    }\r\n\r\n    transformX(x){\r\n        return this.scale*(this.leftOffset+x)\r\n    }\r\n\r\n    transformY(y){\r\n        return this.scale*(this.topOffset-y)\r\n    }\r\n\r\n    point(x, y, color = \"red\", radius = 4){\r\n        this.ctx.beginPath();\r\n        this.ctx.fillStyle = color;\r\n\r\n        this.ctx.arc(\r\n            this.transformX(x), \r\n            this.transformY(y), \r\n            radius, 0, 2 * Math.PI, true\r\n        );\r\n\r\n        this.ctx.fill();\r\n        this.ctx.closePath();\r\n    }\r\n\r\n    // line(x1, y1, x2, y2, type = 1){\r\n\r\n    //     x1 = this.transformX(x1) \r\n    //     y1 = this.transformY(y1)\r\n    //     x2 = this.transformX(x2)\r\n    //     y2 = this.transformY(y2)\r\n\r\n    //     this.ctx.beginPath(); \r\n    //     this.ctx.moveTo(x1, y1);  \r\n    //     this.ctx.lineTo(x2, y2);  \r\n    //     this.ctx.strokeStyle = this.roadTypesColor[type];\r\n    //     this.ctx.lineWidth = 1*(type/1.5);\r\n    //     this.ctx.stroke();  \r\n    //     this.ctx.closePath();\r\n    // }\r\n\r\n    //arrOfPoints = [{x,y}, {x,y}]\r\n    //type 1 - точка, 2 - линиия, 3 - контур\r\n    polyline(arrOfPoints, color, type, bgcolor, lineWidth = 1){\r\n\r\n        if(!arrOfPoints) return;\r\n        if(arrOfPoints.length === 0) return;\r\n\r\n        if(type===1){\r\n            this.point(arrOfPoints[0].x, arrOfPoints[0].y, color, 1)\r\n            return;\r\n        }\r\n\r\n        this.ctx.beginPath();\r\n        \r\n        this.ctx.moveTo(\r\n            this.transformX(arrOfPoints[0].x), \r\n            this.transformY(arrOfPoints[0].y)\r\n        ); \r\n\r\n        \r\n        if(type === 3){\r\n\r\n            for(let i = 1; i < arrOfPoints.length-1; i++){\r\n\r\n                this.ctx.lineTo(\r\n                    this.transformX(arrOfPoints[i].x), \r\n                    this.transformY(arrOfPoints[i].y)\r\n                );\r\n\r\n                if(this.gitHubPages){\r\n                    this.ctx.moveTo(\r\n                        this.transformX(arrOfPoints[i].x), \r\n                        this.transformY(arrOfPoints[i].y)\r\n                    ); \r\n                }\r\n\r\n            }\r\n\r\n            this.ctx.lineTo(\r\n                this.transformX(arrOfPoints[0].x), \r\n                this.transformY(arrOfPoints[0].y)\r\n            );\r\n\r\n            this.ctx.strokeStyle = color;\r\n            this.ctx.lineWidth = lineWidth\r\n            this.ctx.stroke();\r\n\r\n            this.ctx.fillStyle = bgcolor || color;\r\n            this.ctx.fill();\r\n            \r\n        }\r\n\r\n        if(type === 2){\r\n\r\n            for(let i = 1; i < arrOfPoints.length; i++){\r\n                this.ctx.lineTo(\r\n                    this.transformX(arrOfPoints[i].x), \r\n                    this.transformY(arrOfPoints[i].y)\r\n                );\r\n\r\n                if(this.gitHubPages){\r\n                    this.ctx.moveTo(\r\n                        this.transformX(arrOfPoints[i].x), \r\n                        this.transformY(arrOfPoints[i].y)\r\n                    ); \r\n                }\r\n\r\n            }\r\n\r\n            this.ctx.strokeStyle = color;\r\n            this.ctx.lineWidth = lineWidth\r\n            this.ctx.stroke(); \r\n        }\r\n\r\n        this.ctx.closePath();\r\n        \r\n\r\n\r\n    }\r\n\r\n}\n\n//# sourceURL=webpack://gis-moscow-map/./src/draw.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("const Draw = __webpack_require__(/*! ./draw.js */ \"./src/draw.js\")\r\nconst createGraph = __webpack_require__(/*! ngraph.graph */ \"./node_modules/ngraph.graph/index.js\");\r\nconst aStar = __webpack_require__(/*! ./a-star/a-star.js */ \"./src/a-star/a-star.js\")\r\n\r\nconst canvas = document.getElementById(\"canvas\")\r\ncanvas.width  = window.innerWidth;\r\ncanvas.height = window.innerHeight\r\nconst ctx = canvas.getContext(\"2d\");\r\n\r\nlet POINTS = undefined,\r\n    LINES  = undefined,\r\n    CONTOURS = undefined,\r\n    GREENZONES = undefined,\r\n    WATER = undefined,\r\n    BUILDINGS = undefined,\r\n    RAILWAYS = undefined\r\n\r\nlet SCALE = 0.07, \r\n    TOPOFFSET = 30000, \r\n    LEFTOFFSET = 0\r\n\r\nlet draw;\r\n\r\n//let draw = new Draw(ctx, { scale: 0.05, topOffset: 40500 })\r\n    \r\n//Создаем массив объектов из текстовой структуры\r\nfunction parseToArrayOfObject(data){\r\n        \r\n    const lines = data.split('\\n');\r\n    const linesLength = lines.length\r\n\r\n    const arrOfObj = []\r\n\r\n    //The zero line consists structure of object\r\n\r\n    const objStruct = []\r\n    const firstTabs = lines[0].split('\\t');\r\n\r\n    for(const tab of firstTabs) objStruct.push(tab)\r\n\r\n    arrOfObj.push(objStruct)\r\n    \r\n    //The other lines considering objects\r\n\r\n    for(let line = 1; line < linesLength-1; line++){\r\n\r\n        const tabs = lines[line].split('\\t');\r\n        const tabsLength = tabs.length\r\n\r\n        const currentObj = {}\r\n\r\n        for(let tab = 0; tab < tabsLength; tab++) {\r\n            currentObj[objStruct[tab]] = Number(tabs[tab])\r\n        }\r\n\r\n        arrOfObj.push(currentObj)\r\n\r\n    }\r\n\r\n    return arrOfObj\r\n\r\n}\r\n\r\n//Формируем контуры\r\nfunction reduceContour(CONTOURS){\r\n\r\n    const myContours = [null]\r\n\r\n    const CONTOURSLength = CONTOURS.length\r\n\r\n    let currentContour = []\r\n    let lastIdPoints = 1\r\n\r\n    for(let i = 1; i < CONTOURSLength; i++){\r\n\r\n        if(CONTOURS[i].IdPoints === lastIdPoints){\r\n            currentContour.push({x: CONTOURS[i].x, y: CONTOURS[i][\"y\\r\"]})\r\n        }else{\r\n            myContours.push([...currentContour])\r\n            currentContour = []\r\n            currentContour.push({x: CONTOURS[i].x, y: CONTOURS[i][\"y\\r\"]})\r\n        }\r\n\r\n        lastIdPoints = CONTOURS[i].IdPoints\r\n\r\n    }\r\n\r\n    return myContours\r\n\r\n}\r\n\r\n//Отрисовка контуров\r\nfunction drawContours(TYPEOFCONTOURS, CONTOURS, color, bgcolor = undefined, lineWidth = 1){\r\n\r\n    const TYPEOFCONTOURSLength = TYPEOFCONTOURS.length\r\n\r\n    for(let i = 1; i < TYPEOFCONTOURSLength; i++){\r\n\r\n        const contour = CONTOURS[TYPEOFCONTOURS[i].IdPoints]\r\n\r\n        const contourType = TYPEOFCONTOURS[i].IdType || 2\r\n\r\n        draw.polyline(contour, color, contourType, bgcolor, lineWidth)\r\n\r\n    }\r\n\r\n}\r\n\r\nconst setGlobalData = async () => {\r\n\r\n        //Получаем данные\r\n\r\n        const POINTSTextData = await (await fetch('data/Base.ep')).text()\r\n        POINTS = parseToArrayOfObject(POINTSTextData)\r\n    \r\n        const LINESTextData = await (await fetch('data/Base.svdb')).text()\r\n        LINES = parseToArrayOfObject(LINESTextData)\r\n    \r\n        const CONTOURSTextData = await (await fetch('data/Base.epts')).text()\r\n        CONTOURS = reduceContour(parseToArrayOfObject(CONTOURSTextData))\r\n    \r\n        const GREENZONESTextData = await (await fetch('data/Зеленая зона.elyr')).text()\r\n        GREENZONES = parseToArrayOfObject(GREENZONESTextData)\r\n    \r\n        const WATERTextData = await (await fetch('data/Реки и водоемы.elyr')).text()\r\n        WATER = parseToArrayOfObject(WATERTextData)\r\n    \r\n        const BUILDINGSTextData = await (await fetch('data/Жилая застройка.elyr')).text()\r\n        BUILDINGS = parseToArrayOfObject(BUILDINGSTextData)\r\n    \r\n        const RAILWAYSTextData = await (await fetch('data/Железные дороги.elyr')).text()\r\n        RAILWAYS = parseToArrayOfObject(RAILWAYSTextData)\r\n\r\n}\r\n\r\n\r\nconst drawMap = () => {\r\n\r\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n    drawContours(GREENZONES, CONTOURS, '#CAE5B3', '#D4F2BB')\r\n    drawContours(WATER, CONTOURS, '#B8DFF5')\r\n    drawContours(BUILDINGS, CONTOURS, '#E8E8E5', '#F6F6F3')\r\n    drawContours(RAILWAYS, CONTOURS, '#7C6657', '#7C6657', 0.5)\r\n    drawContours(LINES, CONTOURS, '#696969', '#696969', 1)\r\n\r\n}\r\n\r\nconst zoomInOut = (mode) => {\r\n\r\n    switch(mode){\r\n        case 'in': \r\n            SCALE += 0.01\r\n            break;\r\n        case 'out':\r\n            SCALE -= 0.01\r\n            break;\r\n    }\r\n\r\n    draw.scale = SCALE\r\n    \r\n    drawMap();\r\n\r\n}\r\n\r\nconst move = (mode) => {\r\n\r\n    switch(mode){\r\n        case 'top': \r\n            TOPOFFSET -= 1000\r\n            break;\r\n        case 'bottom': \r\n            TOPOFFSET += 1000\r\n            break;\r\n        case 'left':\r\n            LEFTOFFSET -= 1000\r\n            break;\r\n        case 'right':\r\n            LEFTOFFSET += 1000\r\n            break;\r\n    }\r\n\r\n    draw.topOffset = TOPOFFSET\r\n    draw.leftOffset = LEFTOFFSET\r\n\r\n    drawMap();\r\n\r\n}\r\n\r\nconst   zoomInButton = document.getElementById(\"zoom-in\"),\r\n        zoomOutButton = document.getElementById(\"zoom-out\")\r\n        moveTopButton = document.getElementById(\"move-top\")\r\n        moveBottomButton = document.getElementById(\"move-bottom\")\r\n        moveLeftButton = document.getElementById(\"move-left\")\r\n        moveRightButton = document.getElementById(\"move-right\")\r\n    \r\nzoomInButton.addEventListener(\"click\", () => zoomInOut('in'))\r\nzoomOutButton.addEventListener(\"click\", () => zoomInOut('out'))\r\n\r\ncanvas.addEventListener(\"wheel\", (e) => e.deltaY < 0 ? zoomInOut('in') : zoomInOut('out') );\r\n\r\nmoveTopButton .addEventListener(\"click\", () => move('top'))\r\nmoveBottomButton.addEventListener(\"click\", () => move('bottom'))\r\nmoveLeftButton .addEventListener(\"click\", () => move('left'))\r\nmoveRightButton.addEventListener(\"click\", () => move('right'))\r\n\r\nlet isMouseDown = false\r\nlet offsetBeforeMouseUp = [0, 0]\r\n\r\ncanvas.addEventListener('mousedown', (e) => {\r\n    isMouseDown  = true\r\n\r\n    \r\n\r\n    offsetBeforeMouseUp = [e.clientX, e.clientY]\r\n});\r\n\r\ncanvas.addEventListener('mouseup', (e) => {\r\n    isMouseDown = false\r\n\r\n    document.body.style.cursor = 'default'\r\n            \r\n    const [x, y] = offsetBeforeMouseUp\r\n\r\n    if(Math.abs(e.clientX-x) > 40 || Math.abs(e.clientY-y) > 40){\r\n\r\n        LEFTOFFSET += (e.clientX-x)/SCALE\r\n        TOPOFFSET += (e.clientY-y)/SCALE\r\n\r\n        draw.topOffset = TOPOFFSET\r\n        draw.leftOffset = LEFTOFFSET\r\n\r\n        drawMap();\r\n    \r\n    }\r\n\r\n});\r\n\r\n\r\ncanvas.addEventListener('mousemove', function(e) {\r\n\r\n    if(isMouseDown){\r\n\r\n        // const [x, y] = offsetBeforeMouseUp\r\n\r\n        // if(((e.clientX-x) != 0 && Math.abs(e.clientX-x)%10 === 0) || ((e.clientY-y) != 0 && Math.abs(e.clientY-y)%10 === 0)){\r\n    \r\n        //     LEFTOFFSET += (e.clientX-x)/SCALE\r\n        //     TOPOFFSET += (e.clientY-y)/SCALE\r\n    \r\n        //     draw.topOffset = TOPOFFSET\r\n        //     draw.leftOffset = LEFTOFFSET\r\n    \r\n        //     drawMap();\r\n        \r\n        // }\r\n\r\n    }\r\n\r\n})\r\n\r\nconst start = async () => {\r\n\r\n\r\n    await setGlobalData();\r\n\r\n    draw = new Draw(ctx, { scale: SCALE, topOffset: TOPOFFSET, leftOffset: LEFTOFFSET })\r\n    \r\n    draw.gitHubPages = true\r\n\r\n    drawMap();\r\n  \r\n\r\n    //Библиотека для поиска пути на взешенном графе\r\n    //https://habr.com/ru/post/338440/\r\n\r\n    let graph = createGraph();\r\n\r\n    for(let i = 1; i < LINES.length; i++)\r\n        graph.addLink(LINES[i].IdPoint1, LINES[i].IdPoint2, { weight: LINES[i].Length, line: LINES[i] });\r\n    \r\n    const pathFinder = aStar(graph, {\r\n        distance(a, b, link) { return link.data.weight }\r\n    });\r\n\r\n    //FIXME: Широкое поле для рефаторинга)))\r\n\r\n\r\n    const buildWay = (pointOneId, pointTwoId) => {\r\n\r\n        let path = pathFinder.find(pointOneId, pointTwoId);\r\n        path.reverse();\r\n\r\n        let wayLength = 0;\r\n        let pathString = path[0].id;\r\n        let pathArray = [path[0].id]\r\n        let firstPathLine = null\r\n\r\n        try{\r\n            firstPathLine = graph.getNode(path[1].id).links.find(link => link.toId === graph.getNode(path[0].id).id || link.fromId === graph.getNode(path[0].id).id).data.line\r\n            \r\n        }catch(e){\r\n            console.log(\"Ошибка тут\")\r\n        }\r\n\r\n        let pathLines = [firstPathLine]\r\n\r\n        for(let i = 0; i < path.length-1; i++){\r\n            const currentNode = path[i]\r\n            const nextNode = path[i+1]\r\n\r\n            let currentNodeAndNextNodeData\r\n            \r\n            try{\r\n                currentNodeAndNextNodeData = currentNode.links.find(link => link.toId === nextNode.id || link.fromId === nextNode.id).data\r\n            }catch(e){\r\n                console.log(\"Ошибка тут\", currentNode, nextNode)\r\n            }\r\n\r\n            const lengthToNextNode = currentNodeAndNextNodeData.weight\r\n\r\n            //console.log(currentNode.links.)\r\n\r\n            wayLength += lengthToNextNode \r\n            pathString += ` -> ${nextNode.id}`\r\n\r\n            pathLines.push(currentNodeAndNextNodeData.line)\r\n            \r\n            pathArray.push(nextNode.id)\r\n\r\n        }\r\n\r\n        drawContours(pathLines, CONTOURS, 'red', 'red', 2)\r\n        console.log(\"Путь:\", pathString, pathArray, \"Длина:\", wayLength)\r\n\r\n    }\r\n\r\n    let pointOneId = undefined, \r\n        pointTwoId = undefined, \r\n        buildWayMode = false\r\n\r\n    const buildWayButton = document.getElementById(\"build-way\")\r\n    buildWayButton.addEventListener(\"click\", function(e){\r\n        buildWayMode = true\r\n        document.body.style.cursor = 'crosshair'\r\n    })\r\n\r\n\r\n    canvas.addEventListener(\"click\", function(e) {\r\n\r\n        \r\n\r\n        if(buildWayMode){\r\n\r\n            const rect = e.target.getBoundingClientRect();\r\n\r\n            const mousePosX = ((e.clientX-rect.left)/SCALE)-LEFTOFFSET; \r\n            const mousePosY = (TOPOFFSET-((e.clientY-rect.top)/SCALE)) ;\r\n\r\n            let minLength = 100000\r\n            let findedPoint = null\r\n\r\n            for(let i = 1; i < POINTS.length; i++){\r\n\r\n                const lengthBetwenPoints = Math.sqrt(Math.pow((POINTS[i].X - mousePosX), 2) + Math.pow((POINTS[i].Y - mousePosY),2))\r\n\r\n                if(lengthBetwenPoints <= minLength){\r\n                    findedPoint = POINTS[i]\r\n                    minLength = lengthBetwenPoints\r\n                }\r\n\r\n            }\r\n\r\n            console.log(mousePosX, mousePosY)\r\n            console.log(findedPoint)\r\n\r\n            draw.point(findedPoint.X, findedPoint.Y)\r\n    \r\n            if(!pointOneId && !pointTwoId){\r\n\r\n                pointOneId = findedPoint.IdPoint\r\n                \r\n            }else if(pointOneId && !pointTwoId){\r\n\r\n                pointTwoId = findedPoint.IdPoint\r\n\r\n                console.log(\"Строю маршрут между \", pointOneId, \" и \", pointTwoId)\r\n                buildWay(pointOneId, pointTwoId)\r\n\r\n                pointOneId = undefined\r\n                pointTwoId = undefined\r\n                buildWayMode = false\r\n                document.body.style.cursor = 'default'\r\n\r\n            }\r\n\r\n        }\r\n\r\n    })\r\n\r\n\r\n}\r\n\r\nstart()\n\n//# sourceURL=webpack://gis-moscow-map/./src/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;